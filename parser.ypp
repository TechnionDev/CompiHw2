%{
// C user declarations
#include <iostream>
#include "output.hpp"
#include "tokens.hpp"

using std::cout;
using std::endl;
using std::cin;

using output::printProductionRule;
using output::errorSyn;

%}
/* Declarations */
%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc AUTO
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc LPAREN
%nonassoc RPAREN
%nonassoc LBRACE
%nonassoc RBRACE
%nonassoc ID
%nonassoc NUM
%nonassoc STRING
%right NOT
%right ASSIGN
%left RELOP
%left AND
%left OR
%left BINOP


%%
/* Rules */
Program:        Funcs                                                       { printProductionRule(1); };

Funcs:                                                                      { printProductionRule(2); }
                | FuncDecl Funcs                                            { printProductionRule(3); };

FuncDecl:       RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   { printProductionRule(4); };

RetType:        Type                                                        { printProductionRule(5); }
                | VOID                                                      { printProductionRule(6); };

Formals:                                                                    { printProductionRule(7); }
                | FormalsList                                               { printProductionRule(8); };

FormalsList:    FormalDecl                                                  { printProductionRule(9); }
                | FormalDecl COMMA FormalsList                              { printProductionRule(10); };

FormalDecl:     Type ID                                                     { printProductionRule(11); };

Statements:     Statement                                                   { printProductionRule(12); }
                | Statements Statement                                      { printProductionRule(13); };

Statement:      LBRACE Statements RBRACE                                    { printProductionRule(14); }
                | Type ID SC                                                { printProductionRule(15); }
                | Type ID ASSIGN Exp SC                                     { printProductionRule(16); }
                | AUTO ID ASSIGN Exp SC                                     { printProductionRule(17); }
                | ID ASSIGN Exp SC                                          { printProductionRule(18); }
                | Call SC                                                   { printProductionRule(19); }
                | RETURN SC                                                 { printProductionRule(20); }
                | RETURN Exp SC                                             { printProductionRule(21); }
                | IF LPAREN Exp RPAREN Statement %prec IF                   { printProductionRule(22); }
                | IF LPAREN Exp RPAREN Statement ELSE Statement             { printProductionRule(23); }
                | WHILE LPAREN Exp RPAREN Statement                         { printProductionRule(24); }
                | BREAK SC                                                  { printProductionRule(25); }
                | CONTINUE SC                                               { printProductionRule(26); };

Call:           ID LPAREN ExpList RPAREN                                    { printProductionRule(27); }
                | ID LPAREN RPAREN                                          { printProductionRule(28); };

ExpList:        Exp                                                         { printProductionRule(29); }
                | ExpList COMMA ExpList                                     { printProductionRule(30); };

Type:           INT                                                         { printProductionRule(31); }
                | BYTE                                                      { printProductionRule(32); }
                | BOOL                                                      { printProductionRule(33); };

Exp:            LPAREN Exp RPAREN                                           { printProductionRule(34); }
                | Exp BINOP Exp                                             { printProductionRule(35); }
                | ID                                                        { printProductionRule(36); }
                | Call                                                      { printProductionRule(37); }
                | NUM                                                       { printProductionRule(38); }
                | NUM B                                                     { printProductionRule(39); }
                | STRING                                                    { printProductionRule(40); }
                | TRUE                                                      { printProductionRule(41); }
                | FALSE                                                     { printProductionRule(42); }
                | NOT Exp                                                   { printProductionRule(43); }
                | Exp AND Exp                                               { printProductionRule(44); }
                | Exp OR Exp                                                { printProductionRule(45); }
                | Exp RELOP Exp                                             { printProductionRule(46); }
                | LPAREN Type RPAREN Exp                                    { printProductionRule(47); };
%%

/* User routines */
int main() {
    yyparse();
    return 0;
}

// todo: figure out how to use errorSyn/errorLex effectively.
int yyerror(char * s) {
    errorSyn(yylineno);
    exit(1);
}
